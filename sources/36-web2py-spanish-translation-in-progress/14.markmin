## Otras Recetas

### Upgrading
``upgrades``:inxx

En el "site" página de la interfaz administrativa existe un botón "upgrade now". En caso que no esté disponible o no funcione (por ejemplo por problema de bloqueo de un archivo), actualizar web2py manualmente es muy fácil.

-------
Simple descomprime la última versión de web2py sobre la vieja instalación.
-------

Esto actualizará todas las librerías así como también las aplicaciones **admin**, **examples**, **welcome**.  Además también creará un nuevo archivo vacío "NEWINSTALL". Al reiniciar, web2py elimina´ra los archivos vacíos y empaquetará la aplicación "welcome" en "welcome.w2p"  esta será usada como la nueva estructura de la aplicación.
web2py no actualiza cualquier otro archivo existente en otra aplicación.

### Cómo distribuir tus aplicaciones como binarios

Es posible empaquetar tus aplicaciones con la distribución binaria de web2py y distribuirla juntas. La licencia permite esto tan pronto como dejar claro en la licencia de tu aplicación que tu estas agregando web2py y añadas un enlace a ``web2py.com``.

Aquí explicamos como hacer esto para Windows:

- Crea tu aplicación como usalmente lo haces.
- Usando **admin**, compila tu aplicación(one click)
- Usando **admin**, empaqueta la aplicación compilada(another click)
- Descomprime esto en la carpeta "myapp" y comienza ahí (two clicks)
- Carga usando **admin** el anterior paquete de la app compilada con el nombre "init" (one click)
- Crea un archivo "myapp/start.bat" que contenga "cd web2py; web2py.exe"
- comprime la carpeta miaplicacion en un archivo "myapp.zip"
- distribuye y/o vende "myapp.zip"

Cuando los usuarios descompriman "myapp.zip" y hagan click "run" ellos verán tu aplicación en lugar de la aplicación "welcome".
No tiene requerimientos del lado del usuario, ni incluso tener python pre-instalado.

Para binarios en Mac el proceso es el mismo pero no hay necesidad de crear el archivo "bat".

### Construyendo un web2py minimalista

A veces necesitamos implementar web2py en un servidor con muy poca memoria RAM. En este caso nosotros queremos disminuir web2py a su mínima expresión.

Una sencilla manera de hacer esto es la siguiente:
- En una máquina de producción, instala web2py desde las fuentes.
- Desde adentro de la carpeta principal de web2py ejecuta
``
python scripts/make_min_web2py.py /path/to/minweb2py
``
- Ahora copia sobre "/path/to/minweb2py/applications" la aplicación que quieres implementar 
- Implementa "/path/to/minweb2py" a el pequeño servidor.

El script "make_min_web2py.py" creará una distribución mínima de web2py que no incluye:
- admin
- examples
- welcome
- scripts
- raramente usados modulos contrib 

Esto incluye una aplicación "welcome" que consiste de un archivo para permitir la implementación de pruebas.
Mira este script. Al principio contiene una lista detallada de que está incluido y que es ignorado. Tu puedes fácilmente modificarlo y ajustar a tus necesidades.

### Obteniendo una URL externa
``fetch``:inxx

Python includes the ``urllib`` library for fetching urls:
``
import urllib
page = urllib.urlopen('http://www.web2py.com').read()
``:code

``API``:inxx

Esto es usualmente correcto, pero el modulo ``urllib``  no funciona sobre "Google App Engine". Google provee una diferente API para descargar URLs que solamente funciona en GAE. en orden de hacer tu código portable, web2py incluye una función ``fetch`` que funcióna en GAE así mismo en otras instalaciones de Python
``
from google.tools import fetch
page = fetch('http://www.web2py.com')
``:code

### Pretty dates
``prettydate``:inxx

Es usualmente útil para representar un datetime no como "2009-07-25 14:34:56" pero como "one year ago". web2py proporciona una función para esto:
``
import datetime
d = datetime.datetime(2009,7,25,14,34,56)
from gluon.tools import prettydate
pretty_d = prettydate(d,T)
``:code

El segundo argumento (T) debe ser pasado a través de la internacionalización para la salida.

### Geocoding
``geocode``:inxx

Si necesitas convertir una dirección (por ejemplo: "243 S Wabash Ave, Chicago, IL, USA") en coordenadas geográficas (latitud y longitud), web2py provee una función para realizar eso, entonces.
``
from gluon.tools import geocode
address = '243 S Wabash Ave, Chicago, IL, USA'
(latitude, longitude) = geocode(address)
``:code

La función ``geocode`` require una conexión a internet además se conecta al servicio de Google de geocodificación. La función retorna ``(0,0)`` en caso de fallar. Note que el servicio de Google de geocodificación  tiene un número máximo de peticiones, entonces debes verificar sus términos y condiciones. La función  ``geocode`` es implementada al comienzo de la función  ``fetch``  y por esto funcióna en GAE.

### Paginación
``pagination``:inxx

Esta receta es un truco útil para minimizar el acceso a base de dato en el caso de la paginación, e.g., cuando necesitas mostrar una lista de filas desde una basede datos pero quieres distribuir las filas sobre multiples páginas.

Comienza creando una aplicación **primes** que almacene los primeros 1000 números primos en una base de datos.

Acá está el modelo ``db.py``:
``
db = DAL('sqlite://primes.db')
db.define_table('prime',Field('value','integer'))
def isprime(p):
    for i in range(2,p):
        if p%i==0: return False
    return True
if len(db().select(db.prime.id))==0:
   p=2
   for i in range(1000):
       while not isprime(p): p+=1
       db.prime.insert(value=p)
       p+=1
``:code

Ahora crea una acción ``list_items`` in the "default.py" en el controlador que se lea de esta forma:
``
def list_items():
    if len(request.args): page=int(request.args[0])
    else: page=0
    items_per_page=20
    limitby=(page*items_per_page,(page+1)*items_per_page+1)
    rows=db().select(db.prime.ALL,limitby=limitby)
    return dict(rows=rows,page=page,items_per_page=items_per_page)
``:code

Nota que este código selecciona uno o más item de los que necesita, 20+1. el elemento extra dice a la vista si existe la siguiente página.

Aquí es la vista "default/list_items.html":
``
{{extend 'layout.html'}}

{{for i,row in enumerate(rows):}}
{{if i==items_per_page: break}}
{{=row.value}}<br />
{{pass}}

{{if page:}}
<a href="{{=URL(args=[page-1])}}">previous</a>
{{pass}}

{{if len(rows)>items_per_page:}}
<a href="{{=URL(args=[page+1])}}">next</a>
{{pass}}
``:code

En esta manera podemos obtener la paginación con un sólo "select"  por acción,y que un "select" sólo obtenga una fila más de lo que necesita.

### httpserver.log y el Formato del archivo de bitácora.
``httpserver.log``:inxx

El servidor de web2py registra todas las peticiones en un archivo llamado:
``
httpserver.log
``:code

en el directorio raíz de web2py. Un nombre alternativo y ubicación puede ser especificado a través de las opciones de la línea de comandos de web2py.

Nuevas entradas son añadidas al final del archivo cada vez que una peticón es realizada. Cada línea luce como esto:
``
127.0.0.1, 2008-01-12 10:41:20, GET, /admin/default/site, HTTP/1.1, 200, 0.270000
``:code

El formato es:
``
ip, timestamp, method, path, protocol, status, time_taken
``:code

Donde
- ip es la dirección IP del cliente que hico la petición
- timestamp es la fecha y la hora de la petición en el formato ISO 8601, YYYY-MM-DDT HH:MM:SS
- method bien sea GET or POST
- path es la ruta solicitada por el cliente
- protocol es la versión del protocolo HTTP usado para enviar al cliente, usually HTTP/1.1
- status es el código de estado del protocolo HTTP ``status``:cite
- time_taken  es la cantidad de tiempo que el servidor tarda en procesar la petición, en segundos, no incluye tiempos de upload/download.

En el repositorio de aplicaciones ``appliances``:cite , puedrás encontrar una aplicación para el análisis de logs.

Estos registros de logs estan deshabilitado por defecto cuando usas mod_wsgi a partir de esto  podría ser igual como el log de Apache.

### Llenando la Base de dato con dummy data.

Para propósitos de pruebas es conveniente ser capaz de llenar la base de datos con data dummy. web2py incluye un clasificador bayesiano entrenado y listo para generar textos leibles para este propósito.

Esta es la forma más simple de usar:
``
from gluon.contrib.populate import populate
populate(db.mytable,100)
``:code

Esto insertará 100 registros dummy en db.mytable. E intentará hacer inteligentemente la generación de textos cortos para campos que sean cadenas, enteros, doubles, fecha, datetimes, times, booleans, etc. para el campo correspondiente. Intentará respectar los requerimientos impuestos por los validadores. Para campos que contienen la palabra "name" , intentará generar nombres dummy. Para campos referencias serán generadas válidas referencias.

Si tienes dos tablas (A y B) donde  B referencias a  A, comprueba llenar primero a A y a B segundo.

Porque las inserciones son hechas en una transacción, no intente insertar muchísimos registros al mismo tiempo, particularmente si estan involucradas referencias. en su lugar, has un ciclo, insertando 100 cada vez, y commit.
``
for i in range(10):
    populate(db.mytable,100)
    db.commit()
``:code

También puedes usar el clasificador bayesiano para aprender características de algunos textos y generar textos dummys que sean similares, pero podría no tener sentido:
``
from gluon.contrib.populate import Learner, IUP
ell=Learner()
ell.learn('some very long input text ...')
print ell.generate(1000,prefix=None)
``:code

### Aceptando pagos de tarjetas de créditos

``Google Wallet``:inxx ``Paypal``:inxx ``Stripe.com``:inxx
``Authorize.net``:inxx ``DowCommerce``:inxx

Existen multiples maneras de aceptar pagos de tarjetas de créditos por internet. web2py proporciona una API especifica para algunos de los más populares y prácticos:

- Google Wallet ``googlewallet``:cite
- PayPal ``paypal``cite
- Stripe.com ``stripe``:cite
- Authorize.net ``authorizenet``:cite
- DowCommerece ``dowcommerce``:cite


Los primeros dos mecanismos en delegar el proceso de autenticación del pago en un external servicio. Mientras este es la mejor solución para la seguridad (tu aplicación no tiene que manejar alguna información de tarjeta de créditos) esto hace el proceso incómodo (el usuario debe loguearse dos veces; por ejemplo, una vez que tu aplicación, y otra con Google) y no permite que tu aplicación maneje pagos recurrentes en una forma automatizada.

There are times when you need more control and you want to generate yourself the entry form for the credit card info and than programmatically ask the processor to transfer money from the credit card to your account.

Por esta razón web2py provee integración lista para usar con Stripe, Authorize.net (el modulo fue desarrollado por John Conde y ligeramente modificado) y DowCommerce. Stripe es la aplicación más simple de usar y  también la más económica para bajo volumen de transacciones (No cobran un cargo fijo pero el costo por transacción está sobre el 3%). Authorize.net es mejor para altos volúmenes (tiene una tarifa fija anual más un bajo costo por transacción).

Mind that in the case of Stripe and Authorize.net your program will be accepting credit cards information. You do not have to store this information and we advice you not to because of the legal requirements involved (check with Visa or Mastercard) but there are times when you may want to store the information for recurrent payments or to reproduce the Amazon one-click pay button.

#### Google Wallet

The simplest way to use Google Wallet (Level 1) consists of embedding a button on your page that, when clicked, redirects your visitor to a payment page provided by Google.

First of all you need to register a Google Merchant Account at the url:

``
https://checkout.google.com/sell
``

You will need to provide Google with your bank information. Google will assign you a ``merchant_id`` and a ``merchant_key`` (do not confuse them, keep them secret).

Then you simply need to create the following code in your view:

``
{{from gluon.contrib.google_wallet import button}}
{{=button(merchant_id="123456789012345",
           products=[dict(name="shoes",
                          quantity=1,
                          price=23.5,
                          currency='USD',
                          description="running shoes black")])}}
``

When a visitor clicks on the button, the visitor will be redirected to the Google page where he/she can pay for the items. Here products is a list of products and each product is a dictionary of parameters that you want to pass describing your items (name, quantity, price, currency, description, and other optional ones which you can find described in the Google Wallet documentation).

If you choose to use this mechanism you may want to generate the values passed to the button programmatically based on your inventory and the visitor shopping chart.

All the tax and shipping information will be handled on the Google side. Same for accounting information. By default your application is not notified that the transaction has been completed therefore you will have to visit your Google Merchant site to see which products have been purchased and paid for, and which products you need to ship to your buyers there. Google will also send you an email with the information.

If you want a tighter integration you have to use the Level 2 notification API. In that case you can pass more information to Google and Google will call your API to notify about purchases. This allows you to keep accounting information within your application but it requires you expose web services that can talk to Google Wallet.

This is a considerable more difficult problem but such API has already been implemented and it is available as plugin from

``
http://web2py.com/plugins/static/web2py.plugin.google_checkout.w2p
``

You can find the documentation of the plugin in the plugin itself.

#### Paypal

Paypal integration is not described here but you can find more information about it at this resource:

``
http://www.web2pyslices.com/main/slices/take_slice/9
``

#### Stripe.com

This is probably one of the easiest way and flexible ways to accept credit card payments.

You need to register with Stripe.com and that is a very easy process, in fact Stripe will assign you an API key to try even before you create any credentials.

Once you have the API key you can accept credit cards with the following code:

``
from gluon.contrib.stripe import Stripe
stripe = Stripe(api_key)
d = stripe.charge(amount=100,
	      currency='usd',
              card_number='4242424242424242',
              card_exp_month='5',
              card_exp_year='2012',
              card_cvc_check='123',
              description='the usual black shoes')
if d.get('paid',False):
    # payment accepted
elif:
    # error is in d.get('error','unknown')
``

The response, ``d``, is a dictionary which you can explore yourself. The card number used in the example is a sandbox and it will always succeed. Each transaction is associated to a transaction id stored in ``d['id']``.

Stripe also allows you verify a transaction at a later time:

``
d = Stripe(key).check(d['id'])
``

and refund a transaction:

``
r = Stripe(key).refund(d['id'])
if r.get('refunded',False):
    # refund was successful
elif:
    # error is in d.get('error','unkown')
``

Stripe makes very easy to keep the accounting within your application.

All the communications between your app and Stripe go over RESTful web services. Stripe actually exposes even more services and provides a larger set of Python API. You can read more on their web site.

#### Authorize.Net

Another simple way to accept credit cards is to use Authorize.Net. As usual you need to register and you will obtain a ``login`` and a transaction key (``transkey``. Once you have them it works very much like Stripe does:

``
from gluon.contrib.AuthorizeNet import process
if process(creditcard='4427802641004797',
           expiration="122012,
           total=100.0,cvv='123',tax=None,invoice=None,
           login='cnpdev4289', transkey='SR2P8g4jdEn7vFLQ',testmode=True):
   # payment was processed
else:
   # payment was rejected
``:code

If you have a valid Authorize.Net account you should replace the sandbox ``login`` and ``transkey`` with those of your account, set ``testmode=False`` to run on the real platform instead of the sandbox, and use credit card information provided by the visitor.

If ``process`` returns ``True``, the money has been transferred from the visitor credit card account to your Authorize.Net account. ``invoice`` is just a string that you can set and will be store by Authorize.Net with this transaction so that you can reconcile the data with the information in your application.

Here is a more complex example of workflow where more variables are exposed:
``
from gluon.contrib.AuthorizeNet import AIM
payment = AIM(login='cnpdev4289',
              transkey='SR2P8g4jdEn7vFLQ',
              testmod=True)
payment.setTransaction(creditcard, expiration, total, cvv, tax, invoice)
payment.setParameter('x_duplicate_window', 180) # three minutes duplicate windows
payment.setParameter('x_cust_id', '1324')       # customer ID
payment.setParameter('x_first_name', 'Agent')
payment.setParameter('x_last_name', 'Smith')
payment.setParameter('x_company', 'Test Company')
payment.setParameter('x_address', '1234 Main Street')
payment.setParameter('x_city', 'Townsville')
payment.setParameter('x_state', 'NJ')
payment.setParameter('x_zip', '12345')
payment.setParameter('x_country', 'US')
payment.setParameter('x_phone', '800-555-1234')
payment.setParameter('x_description', 'Test Transaction')
payment.setParameter('x_customer_ip', socket.gethostbyname(socket.gethostname()))
payment.setParameter('x_email', 'you@example.com')
payment.setParameter('x_email_customer', False)

payment.process()
if payment.isApproved():
    print 'Response Code: ', payment.response.ResponseCode
    print 'Response Text: ', payment.response.ResponseText
    print 'Response: ', payment.getResultResponseFull()
    print 'Transaction ID: ', payment.response.TransactionID
    print 'CVV Result: ', payment.response.CVVResponse
    print 'Approval Code: ', payment.response.AuthCode
    print 'AVS Result: ', payment.response.AVSResponse
elif payment.isDeclined():
    print 'Your credit card was declined by your bank'
elif payment.isError():
    print 'It did not work'
print 'approved',payment.isApproved()
print 'declined',payment.isDeclined()
print 'error',payment.isError()
``:code

Notice the code above uses a dummy test account. You need to register with Authorize.Net (it is not a free service) and provide your own login, transkey, testmode=True or False to the AIM constructor.

### Dropbox API

``Dropbox.com``:inxx

Dropbox is a very popular storage service. It not only stores your files but it keeps the cloud storage in sync with all your machines. It allows you to create groups and give read/write permissions to the various folders to individual users or groups. It also keeps version history of all your files. It includes a folder called "Public" and each file you put in there will have its own public URL. Dropbox is a great way to collaborate.

You can access dropbox easily by registering at

``
https://www.dropbox.com/developers
``

you will get an ``APP_KEY`` and an ``APP_SECRET``. Once you have them you can use Dropbox to authenticate your users.

Create a file called "yourapp/private/dropbox.key" and in it write
``
<APP_KEY>:<APP_SECERT>:app_folder
``
where ``<APP_KEY>`` and ``APP_SECRET`` are your key and secret.

Then in "models/db.py" do:

``
from gluon.contrib.login_methods.dropbox_account import use_dropbox
use_janrain(auth,filename='private/dropbox.key')
mydropbox = auth.settings.login_form
``

This will allow users to login into your app using their dropbox credentials, and your program will be able to upload files into their dropbox account:

``
stream = open('localfile.txt','rb')
mydropbox.put('destfile.txt',stream)
``

download files:

``
stream = mydropbox.get('destfile.txt')
open('localfile.txt','wb').write(read)
``

and get directory listings:

``
contents = mydropbox.dir(path = '/')['contents']
``

### Twitter API

Here are some quick examples on how to post/get tweets. No third-party libraries are required, since Twitter uses simple RESTful APIs.

Here is an example of how to post a tweet:
``
def post_tweet(username,password,message):
    import urllib, urllib2, base64
    import gluon.contrib.simplejson as sj
    args= urllib.urlencode([('status',message)])
    headers={}
    headers['Authorization'] = 'Basic '+base64.b64encode(
        username+':'+password)
    req = urllib2.Request(
        'http://twitter.com/statuses/update.json',
        args, headers)
    return  sj.loads(urllib2.urlopen(req).read())
``:code

Here is an example of how to receive tweets:
``
def get_tweets():
    user='web2py'
    import urllib
    import gluon.contrib.simplejson as sj
    page = urllib.urlopen('http://twitter.com/%s?format=json' % user).read()
    tweets=XML(sj.loads(page)['#timeline'])
    return dict(tweets=tweets)
``:code

For more complex operations, refer to the Twitter API documentation.

### Streaming virtual files
``streaming``:inxx

It is common for malicious attackers to scan web sites for vulnerabilities. They use security scanners like Nessus to explore the target web sites for scripts that are known to have vulnerabilities. An analysis of web server logs from a scanned machine or directly in the Nessus database reveals that most of the known vulnerabilities are in PHP scripts and ASP scripts. Since we are running web2py, we do not have those vulnerabilities, but we will still be scanned for them. This is annoying, so we like to respond to those vulnerability scans and make the attacker understand their time is being wasted.

One possibility is to redirect all requests for .php, .asp, and anything suspicious to a dummy action that will respond to the attack by keeping the attacker busy for a large amount of time. Eventually the attacker will give up and will not scan us again.

This recipe requires two parts.

A dedicated application called **jammer** with a "default.py" controller as follows:
``
class Jammer():
   def read(self,n): return 'x'*n
def jam(): return response.stream(Jammer(),40000)
``:code

When this action is called, it responds with an infinite data stream full of "x"-es. 40000 characters at a time.

The second ingredient is a "route.py" file that redirects any request ending in .php, .asp, etc. (both upper case and lower case) to this controller.
``
route_in=(
 ('.*\.(php|PHP|asp|ASP|jsp|JSP)','jammer/default/jam'),
)
``:code

The first time you are attacked you may incur a small overhead, but our experience is that the same attacker will not try twice.

